
lib_ml_files=$(find src/lib/ -type f -name '*.ml')
lib_mli_files=$(find src/lib/ -type f -name '*.mli')
lib_files="$lib_mli_files $lib_ml_files"

setup() {
  set -e
  local quoted_authors_list=""
  for idx in "${authors[@]}" ; do
    eval name=\${$idx[0]}
    eval email=\${$idx[1]}
    quoted_authors_list="$quoted_authors_list \"$name <$email>\""
  done


  mkdir -p _obuild/gen/
  local lib_atd_files=$(find src/atd/ -type f -name '*.atd')
  for atd in $lib_atd_files ; do
    name=`basename $atd`
    atd2cconv -inline-inherit-variants true -i $atd -o _obuild/gen/ketrew_gen_${name%.atd}.ml
  done

  local ocaml_findlib_packages_list=$(for f in $findlib_packages ; do echo "\"$f\"; " ; done)
  cat <<EOBLOB > _obuild/gen/ketrew_metadata.ml
  let version = "$version_string"
  let findlib_packages = [$ocaml_findlib_packages_list]
  let homepage = "$homepage"
EOBLOB
  local lib_gen_files=$(find _obuild/gen/ -type f -name '*.ml')

  local quoted_lib_files=$(for f in $lib_files ; do echo "\"$f\" " ; done)
  local quoted_gen_files=$(for f in $lib_gen_files ; do echo "\"$f\" " ; done)

  local yojson_hack_dir=$PWD/_prebuild/yojson
  mkdir -p $yojson_hack_dir
  cp -r `ocamlfind query yojson`/* $yojson_hack_dir
  cd $yojson_hack_dir 
  ocamlc -a -o yojson.cma `ocamlfind query easy-format`/easy_format.cmo yojson.cmo
  ocamlopt -a -o yojson.cmxa `ocamlfind query easy-format`/easy_format.cmx yojson.cmx
  cd -

  local quoted_findlib_packages=$(for f in $findlib_packages ; do echo "\"$f\" " ; done)
cat << OCP_END > build.ocp
version = "$version_string"
license = "$license_name"
authors = [ $quoted_authors_list ]
begin library "threads"
  generated = true
  dirname = [ "%{OCAMLLIB}%/threads" ]
  has_byte = false
end
begin library "yojson"
  generated = true
  dirname = [ "$yojson_hack_dir" ]
  requires = [ "easy-format" "biniou"  ]
end
begin  library "ketrew"
  sort = true
  files = [
    $quoted_lib_files
    $quoted_gen_files
  ]
  requires = [ "easy-format" "biniou" $quoted_findlib_packages ]
  comp = [ "-thread" ]
  link = [ "-thread" ]
end
begin program "ketrew-test"
  files = [ "src/test/main.ml" ]
  requires = [ "ketrew" "threads" ]
  link = [ "-thread" ]
  comp = ["-thread" ]
  install = false
end
begin program "ketrew-app"
  files = [ "src/app/main.ml" ]
  requires = [ "ketrew" "threads" ]
  link = [ "-thread" ]
  comp = ["-thread" ]
end
begin program "ketrew-cli-test"
  files = [ "src/test/Workflow_Examples.ml" ]
  requires = [ "ketrew" "threads" ]
  link = [ "-thread" ]
  comp = ["-thread" ]
  install = false
end
begin program "ketrew-integration-test"
  files = [ "src/test/integration.ml" ]
  requires = [ "ketrew" "threads" ]
  link = [ "-thread" ]
  comp = ["-thread" ]
  install = false
end
OCP_END

cat << MERLIN_END > .merlin
S ./src/lib/
S ./src/test/
B _obuild/ketrew
B _obuild/ketrew-test
MERLIN_END
for p in $findlib_packages ; do echo "PKG $p" >> .merlin ; done

ocp-build root

}


#
# ocp-build install seems broken
# so here is a dirty implementation of META/install/uninstall
#
meta_file () {
  local meta=$1
  cat << EOF_META > $meta
version = "$version_string"
description = "The Ketrew workflow engine"
requires = "$findlib_packages"
archive(byte) = "ketrew.cma"
archive(native) = "ketrew.cmxa"
exists_if = "ketrew.cma"
EOF_META
}
install () {
    local prefix=$1
    meta_file _obuild/ketrew/META
    ocamlfind install ketrew _obuild/ketrew/META _obuild/ketrew/*.*
    local kclient=_obuild/ketrew-app/ketrew-app
    if [ -f $kclient.asm ] ; then
        cp $kclient.asm $prefix/bin/ketrew
    else
        cp $kclient.byte $prefix/bin/ketrew
    fi
}
uninstall () {
    local prefix=$1
    ocamlfind remove ketrew
    rm -f $prefix/bin/ketrew
}

build () {
  set -e
  if [ -f build.ocp ]; then
    echo "Not redoing setup"
  else
    echo "Calling setup"
    setup
  fi
  ocp-build $* ketrew  ketrew-app ketrew-cli-test ketrew-test ketrew-integration-test
  echo "Compiling also dummy-plugins and stuff"
  compile_dummy_plugin
}

